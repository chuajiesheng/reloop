
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial &mdash; reloop 0.0.1a documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/ls8layout.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="reloop 0.0.1a documentation" href="index.html" />
    <link rel="next" title="RAMPL" href="RAMPL.html" />
    <link rel="prev" title="Installation" href="installation.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www-ai.cs.uni-dortmund.de/weblab/index.html"><img class="intro-logo" src="_static/tulogo.svg">
        </a>
        <span class="navbar-text navbar-ls8-title">
          reloop<span class="navbar-version"><b> (0.0.1)</b></span>
        </span>
      </div>

      <div class="collapse navbar-collapse nav-collapse navbar-right">
        <ul class="nav navbar-nav">
          
              <li><a href="index.html">Home</a></li>
              <li><a href="download.html">Download</a></li>
          
          
            
<li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Index <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installation.html#main-dependencies">Main dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#optional-dependencies">Optional dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#installing-reloop">Installing reloop</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#relational-linear-programming">Relational Linear Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equitable-partitions-and-lifted-linear-programming">Equitable Partitions and Lifted Linear Programming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RAMPL.html">RAMPL</a></li>
<li class="toctree-l1"><a class="reference internal" href="LLP.html">LLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python_maxflow_operator.html">maxflow_operator.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_maxflow_text.html">maxflow_text.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_lift_factorgraph.html">lift_factorgraph.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_lift_Abc.html">lift_Abc.py</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="code.html">Code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python.html">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="cython.html">Cython</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpp.html">CPlusPlus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>
</ul>
</li>
            
          
          
          
          
          
        </ul>

        
          
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        
      </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="id1">
<h1>Tutorial<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>TODO: intro</p>
<div class="contents local topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#relational-linear-programming" id="id2">Relational Linear Programming</a><ul>
<li><a class="reference internal" href="#a-relational-linear-program-for-maximum-flow-modelling-in-operator-notation" id="id3">A Relational Linear Program for Maximum Flow: Modelling in Operator Notation</a></li>
<li><a class="reference internal" href="#a-logical-knowledge-base-for-the-flow-rlp" id="id4">A Logical Knowledge Base for the Flow RLP</a></li>
<li><a class="reference internal" href="#solving-instances-of-relational-flow-lp" id="id5">Solving Instances of Relational Flow LP</a></li>
<li><a class="reference internal" href="#modeling-in-text-notation" id="id6">Modeling in Text Notation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#equitable-partitions-and-lifted-linear-programming" id="id7">Equitable Partitions and Lifted Linear Programming</a><ul>
<li><a class="reference internal" href="#equitable-partitions-of-matrices" id="id8">Equitable Partitions of Matrices</a></li>
<li><a class="reference internal" href="#lifting-an-mrf-factor-graph" id="id9">Lifting an MRF Factor Graph</a></li>
<li><a class="reference internal" href="#lifting-linear-programs" id="id10">Lifting Linear Programs</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="relational-linear-programming">
<h2><a class="toc-backref" href="#id2">Relational Linear Programming</a><a class="headerlink" href="#relational-linear-programming" title="Permalink to this headline">¶</a></h2>
<p>Mathematical programs (MPs) are often specified using algebraic modelling languages such as AMPL. They simplify MP definition by allowing to use algebraic
notation instead of matrices and define an objective and constraints through parameters whose domains are defined in a separate file,
thus enabling separating the model from its instances. That is, algebraic modeling languages such as AMPL allow one to write down the problem description
in a declarative way. They free the user from engineering instance specific MPs while capturing the general properties of the problem class at hand.
However, they do not provide logically parameterized definitions for the arithmetic expressions and for the index sets. RAMPL, which we will introduce now,
feature exactly this.</p>
<p>Let&#8217;s consider a traffic flow problem, i.e., we are given a transportation network consisting of a source (S), sink (T), and
intermediate nodes connected with links of certain capacity. For example, consider the following network.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/flownetwork.svg"><img alt="transportation network" src="_images/flownetwork.svg" /></a>
<p class="caption">Transportation network for the flow LP. Numbers indicate capacities of the links.</p>
</div>
<p>Our task is to find a way to route as much goods from the source to the sink as the network allows. One popular way to do this is using a linear program. Let us briefly describe what an LP for the max flow problem could look like. The first step to a linear programming model of the flow problem is to assign a continuous variable to each edge in the network. Our intention is that in the LP solution, these variables will hold the amount of goods flowing on the edges. In order to get an admissible flow, however, we need to constrain these variables. Clearly, the amount of goods flowing on an edge must not exceed its capacity. This is a linear constraint on the flow variables. Another linear constraint is that a flow must be nonnegative (by convention). Finally, we have to need to introduce flow conservation: the amount of goods flowing in each node must be equal to the amount of goods flowing out (except for the source and sink nodes). The LP we end up with is as follows:</p>
<div class="math">
\[\begin{split}\operatorname*{maximize}\limits_{{\bf f} \in \mathbb{R}^{|E|}}  &amp;\quad \sum_{v: (s,v)\in E} f_{sv} \\
          \text{s.t.} &amp;\quad \forall v\in V\setminus \{s, t\} : \sum\nolimits_{u: (u,v) \in E} f_{uv} = \sum\nolimits_{u: (v,u) \in E} f_{vu} \;,\\
          &amp; \quad \forall e \in E: \quad 0 \leq f_e \leq c_e\;.\end{split}\]</div>
<p>To add structure to this LP, let us make the following definitions:</p>
<div class="math">
\[\begin{split}\operatorname*{inFlow}(X) := \sum\nolimits_{u: (u,X) \in E} f_{uX}\; ,\\
\operatorname*{outFlow}(X) := \sum\nolimits_{u: (X,u) \in E} f_{Xu}\;.\\\end{split}\]</div>
<p>We thus end up with:</p>
<div class="math">
\[\begin{split}\operatorname*{maximize}\limits_{{\bf f} \in \mathbb{R}^{|E|}}  &amp;\quad \sum_{v: (s,v)\in E} f_{sv} \\
          \text{s.t.} &amp;\quad \forall v\in V\setminus \{s, t\} : \operatorname*{inFlow}(v) = \operatorname*{outFlow}(v)\;,\\
          &amp; \quad \forall e \in E: \quad 0 \leq f_e \leq c_e\;.\end{split}\]</div>
<p>We will now show how to use reloop&#8217;s RLP language to construct and solve this model.</p>
<div class="section" id="a-relational-linear-program-for-maximum-flow-modelling-in-operator-notation">
<h3><a class="toc-backref" href="#id3">A Relational Linear Program for Maximum Flow: Modelling in Operator Notation</a><a class="headerlink" href="#a-relational-linear-program-for-maximum-flow-modelling-in-operator-notation" title="Permalink to this headline">¶</a></h3>
<p>(The running code for this example can be found in <a class="reference internal" href="python_maxflow_operator.html#maxflowoperator"><em>maxflow_operator.py</em></a>.)</p>
<p>The start of your file will import reloop’s functions for use in your code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">reloop.languages.rlp</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>A variable called model (although its name is not important) is created using the reloopProblem function. It has two parameters, the first being the
arbitrary name of this problem (as a string), and the second parameter being either LpMinimize or LpMaximize depending on the type of LP we are trying to solve:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">=</span> <span class="n">reloopProblem</span><span class="p">(</span><span class="s">&quot;flow LP&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">LpMaximize</span><span class="p">)</span>
</pre></div>
</div>
<p>Before we start defining constraints, we will declare our predicates. In this case we have 2 of them: <tt class="docutils literal"><span class="pre">flow</span></tt> &#8211; our variable predicate, and <tt class="docutils literal"><span class="pre">cap</span></tt>, which stores the capacities of the edges. We declare them as follows</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">flow</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;flow&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">cap</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;cap&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">predicate()</span></tt> takes as arguments the predicate name, the arity and optionally whether the predicate is an LP variable (by default assumed false).</p>
<p>We will now illustrate the concept of substitutions to define <tt class="docutils literal"><span class="pre">outFlow</span></tt> and <tt class="docutils literal"><span class="pre">inFlow</span></tt>. A substitution is essentially a preprocessor instruction to replace one piece of text with another. In particular we want the atoms <tt class="docutils literal"><span class="pre">inFlow</span></tt> and <tt class="docutils literal"><span class="pre">outFlow</span></tt> to always be replaced by the sums defined above. We first declare the two predicates as substitutions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inFlow</span> <span class="o">=</span> <span class="n">Substitution</span><span class="p">(</span><span class="s">&quot;inFlow&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">outFlow</span> <span class="o">=</span> <span class="n">Substitution</span><span class="p">(</span><span class="s">&quot;outFlow&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we define them</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">outFlow</span> <span class="o">&lt;&lt;=</span> <span class="p">[</span> <span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="n">psum</span><span class="p">(</span><span class="s">&quot;Y in edge(X,Y)&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;Y&quot;</span><span class="p">))</span> <span class="p">]</span>
<span class="n">inFlow</span>  <span class="o">&lt;&lt;=</span> <span class="p">[</span> <span class="s">&quot;Y&quot;</span><span class="p">,</span> <span class="n">psum</span><span class="p">(</span><span class="s">&quot;X in edge(X,Y)&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span><span class="s">&#39;Y&#39;</span><span class="p">))</span> <span class="p">]</span>
</pre></div>
</div>
<p>where the definition takes a list of a varlist and expression. In essence, the above is roughly equivalent to the C directive</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define outFlow(X) psum(&quot;Y in edge(X,Y)&quot;, flow(&quot;X&quot;,&quot;Y&quot;))</span>
</pre></div>
</div>
<p>I.e., whenever something like <tt class="docutils literal"><span class="pre">outFlow(A)</span></tt> is encountered in our model, <tt class="docutils literal"><span class="pre">A</span></tt> will be bound to <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">outFlow(A)</span></tt> will be replaced by <tt class="docutils literal"><span class="pre">psum(&quot;Y</span> <span class="pre">in</span> <span class="pre">edge(A,Y)&quot;,</span> <span class="pre">flow(&quot;A&quot;,&quot;Y&quot;))</span></tt>. Substitutions with multiple variables are also possible.</p>
<p>Now we start collecting our model specification in the <tt class="docutils literal"><span class="pre">model</span></tt> variable using the += operator.
We start with our objective, namely that the flow out of the source node must be maximized. We specify that using the <tt class="docutils literal"><span class="pre">pobj()</span></tt> function, which takes an arithmetic expression as argument</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">+=</span> <span class="n">pobj</span><span class="p">(</span><span class="n">psum</span><span class="p">(</span><span class="s">&quot;X, Y in source(X) &amp; edge(X,Y)&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;Y&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>This says that we want to sum all <tt class="docutils literal"><span class="pre">flow(X,Y)</span></tt> terms for which <tt class="docutils literal"><span class="pre">X</span></tt> is a source node and there is an edge between <tt class="docutils literal"><span class="pre">X</span></tt> and <tt class="docutils literal"><span class="pre">Y</span></tt>.</p>
<p>Next, we encode the preservation of in- and outflows for all nodes that are not the source resp. target nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">+=</span> <span class="n">pall</span><span class="p">(</span><span class="s">&quot;Z in node(Z) &amp; ~source(Z) &amp; ~target(Z)&quot;</span><span class="p">,</span> <span class="n">inFlow</span><span class="p">(</span><span class="s">&quot;Z&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">outFlow</span><span class="p">(</span><span class="s">&quot;Z&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The function <tt class="docutils literal"><span class="pre">pall()</span></tt> (i.e. forall) takes a query and parequation as argument. It instantiates a ground constraint for every variable in the answer of the query.
This constraint says that except for the entrance and exit, the flow into each intersection
equals the flow out. Note that we have made use of negation in the query of the forall quantification using ~.</p>
<p>Next, the capacity and traffic load are defined for each link:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">+=</span> <span class="n">pall</span><span class="p">(</span><span class="s">&quot;X,Y in edge(X,Y)&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;Y&quot;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cap</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;Y&quot;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Again, we have used cap/2 to refer to the corresponding values. The relational constraint introduces upper bounds for
all flow/2 variables. Finally, we include also the lower bounds:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">+=</span> <span class="n">pall</span><span class="p">(</span><span class="s">&quot;X,Y in edge(X,Y)&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span><span class="s">&quot;Y&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Now that all the model is specified, we still have to add the definitions of the logical predicates and parameters. When we have done this, we could print the induced
LP using the &#8220;print model&#8221;. We could even use the writeLP() to copy this information into a .lp file into the directory
that your code-block is running from. Once your code runs successfully, you can open this .lp file with a text editor to see what the above steps were doing.</p>
<p>This allows one to express LPs relationally for a varying number of individuals and relations among them without enumerating them.
Together with a logical knowledge base, effectively a logical program consisting of logical facts and rules, it induces a ground LP as we will show next.</p>
</div>
<div class="section" id="a-logical-knowledge-base-for-the-flow-rlp">
<h3><a class="toc-backref" href="#id4">A Logical Knowledge Base for the Flow RLP</a><a class="headerlink" href="#a-logical-knowledge-base-for-the-flow-rlp" title="Permalink to this headline">¶</a></h3>
<p>Fist we define the node/1 predicate, i.e., the set of nodes in the flow network. To do so, we use pyDatalog and its decorator:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@pyDatalog.predicate</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">node1</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;g&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the same way we next define the links resp. edges of the traffic networks as well as the source and target nodes resp. intersections</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@pyDatalog.predicate</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">edge2</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">):</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">)</span>



<span class="nd">@pyDatalog.predicate</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">source1</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>

<span class="nd">@pyDatalog.predicate</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">target1</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;g&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we still habe to define the capacities of all links. To so so, we specify the cost(X,Y,Z) predicate econcoding
costs(X,Y)=Z:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@pyDatalog.predicate</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cap3</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">):</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="mi">60</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="mi">60</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">,</span><span class="mi">70</span><span class="p">)</span>
    <span class="k">yield</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">,</span><span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="solving-instances-of-relational-flow-lp">
<h3><a class="toc-backref" href="#id5">Solving Instances of Relational Flow LP</a><a class="headerlink" href="#solving-instances-of-relational-flow-lp" title="Permalink to this headline">¶</a></h3>
<p>To obtain the solution to this instance of the relational flow linear program, we could just call the solve() function.
It calls PuLP&#8217; solver. Since everything is embedded within Python, we could also use Python to process
the solution even further:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

<span class="k">print</span> <span class="s">&quot;The model has been solved: &quot;</span> <span class="o">+</span> <span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>

<span class="n">sol</span> <span class="o">=</span>  <span class="n">model</span><span class="o">.</span><span class="n">getSolution</span><span class="p">()</span>

<span class="k">print</span> <span class="s">&quot;The solutions for the flow variables are:</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="k">if</span> <span class="s">&quot;flow&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">key</span><span class="o">+</span><span class="s">&quot; = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="k">if</span> <span class="s">&quot;flow&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span>

<span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Thus, the maximum flow entering the traffic network at node a is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="s">&quot;flow(&#39;a&#39;,&#39;b&#39;)&quot;</span><span class="p">]</span><span class="o">+</span><span class="n">sol</span><span class="p">[</span><span class="s">&quot;flow(&#39;a&#39;,&#39;c&#39;)&quot;</span><span class="p">])</span><span class="o">+</span><span class="s">&quot; cars per hour.&quot;</span>
<span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">The total flow in the traffic network is &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; cars per hour.&quot;</span>
</pre></div>
</div>
<p>This produces the following output:</p>
<div class="highlight-python"><div class="highlight"><pre>The model has been solved: Optimal
The solutions for the flow variables are:

    flow(b,e) = 20.0
    flow(d,f) = 40.0
    flow(f,g) = 60.0
    flow(c,f) = 20.0
    flow(a,b) = 50.0
    flow(c,d) = 60.0
    flow(e,g) = 70.0
    flow(a,c) = 80.0
    flow(b,d) = 30.0
    flow(d,e) = 50.0


Thus, the maximum flow entering the traffic network at node a is 130.0 cars per hour.

The total flow in the traffic network is 480.0 cars per hour.
</pre></div>
</div>
<p>Of course, changing the knowledge base will result in different solutions. The corresponding .lp file (produced e.g. by PuLP) would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre>flow LP:
MAXIMIZE
1.0*flow(a,b) + 1.0*flow(a,c) + 0
SUBJECT TO
_C1: flow(c,f) + flow(d,f) - flow(f,g) = 0
_C2: flow(b,d) + flow(c,d) - flow(d,e) - flow(d,f) = 0
_C3: flow(a,b) - flow(b,d) - flow(b,e) = 0
_C4: flow(b,e) + flow(d,e) - flow(e,g) = 0
_C5: flow(a,c) - flow(c,d) - flow(c,f) = 0
_C6: flow(e,g) &lt;= 70
_C7: flow(c,d) &lt;= 60
_C8: flow(c,f) &lt;= 20
_C9: flow(a,b) &lt;= 50
_C10: flow(f,g) &lt;= 70
_C11: flow(b,e) &lt;= 20
_C12: flow(a,c) &lt;= 100
_C13: flow(d,f) &lt;= 60
_C14: flow(b,d) &lt;= 40
_C15: flow(d,e) &lt;= 50
_C16: flow(d,e) &gt;= 0
_C17: flow(e,g) &gt;= 0
_C18: flow(a,b) &gt;= 0
_C19: flow(b,e) &gt;= 0
_C20: flow(c,f) &gt;= 0
_C21: flow(f,g) &gt;= 0
_C22: flow(a,c) &gt;= 0
_C23: flow(b,d) &gt;= 0
_C24: flow(d,f) &gt;= 0
_C25: flow(c,d) &gt;= 0

VARIABLES
flow(a,b) free Continuous
flow(a,c) free Continuous
flow(b,d) free Continuous
flow(b,e) free Continuous
flow(c,d) free Continuous
flow(c,f) free Continuous
flow(d,e) free Continuous
flow(d,f) free Continuous
flow(e,g) free Continuous
flow(f,g) free Continuous
</pre></div>
</div>
<p>The complete running example can be found <a class="reference internal" href="python_maxflow_operator.html#maxflowoperator"><em>here</em></a>.</p>
</div>
<div class="section" id="modeling-in-text-notation">
<h3><a class="toc-backref" href="#id6">Modeling in Text Notation</a><a class="headerlink" href="#modeling-in-text-notation" title="Permalink to this headline">¶</a></h3>
<p>The RLP envirnonment allows the user to also enter the equations in text form, as introduced in (TODO: paper).
To illustrate, we will show how the flow LP looks like in text form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">model</span> <span class="o">=</span> <span class="n">reloopProblem</span><span class="p">(</span><span class="s">&quot;flow LP&quot;</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">LpMaximize</span><span class="p">)</span>

<span class="c"># declarations</span>
<span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;flow&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;cap&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;inFlow&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="s">&quot;outFlow&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
<span class="c"># the objective function is added to relational LP first</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="s">&quot;sum{ X,Y in source(X) &amp; edge(X,Y) } : { flow(X,Y) }&quot;</span><span class="p">)</span>
<span class="c"># constraints defining inflow are added</span>
<span class="nb">input</span> <span class="o">=</span> <span class="s">&quot;forall{ Y in node(Y) &amp; ~source(Y) } : { sum{ X in edge(X,Y) } : { 1.0*flow(X,Y)} = inFlow(Y)}&quot;</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="c"># constraints defining outflow are added</span>
<span class="nb">input</span> <span class="o">=</span> <span class="s">&quot;forall{ X in node(X) &amp; ~target(X) } : { sum{ Y in edge(X,Y) } : { 1.0*flow(X,Y) }  = outFlow(X)}&quot;</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="c"># constraints defining preservation of flow are added</span>
<span class="nb">input</span> <span class="o">=</span> <span class="s">&quot;forall{ X in node(X) &amp; ~source(X) &amp; ~target(X)} : { inFlow(X) = outFlow(X) }&quot;</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="c"># constraints defining lower and upper bounds are added</span>
<span class="nb">input</span> <span class="o">=</span> <span class="s">&quot;forall{ X,Y in edge(X,Y) } : { flow(X,Y) &gt;= 0}&quot;</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="nb">input</span> <span class="o">=</span> <span class="s">&quot;forall{ X,Y in edge(X,Y) } : { flow(X,Y) &lt;= cap(X,Y)}&quot;</span>
<span class="n">model</span> <span class="o">+=</span> <span class="n">reloopConstraint</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
</pre></div>
</div>
<p>You can find the running code in <a class="reference internal" href="python_maxflow_text.html#maxflowtext"><em>maxflow_text.py</em></a>.</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Substitutions are not yet implemented in text mode. As you can see, we have implemented <tt class="docutils literal"><span class="pre">inFlow</span></tt> and <tt class="docutils literal"><span class="pre">outFlow</span></tt> as LP variables and their definitions as LP constraints.</p>
</div>
</div>
</div>
<div class="section" id="equitable-partitions-and-lifted-linear-programming">
<h2><a class="toc-backref" href="#id7">Equitable Partitions and Lifted Linear Programming</a><a class="headerlink" href="#equitable-partitions-and-lifted-linear-programming" title="Permalink to this headline">¶</a></h2>
<p>Next to modeling languages, reloop offers tools for efficiently lifting and solving optimization problems produced by these languages (and not only). In the lifted solvers provided, efficiency is gained by exploiting redundancy in the structure of the problem. Our main tool for redundancy discovery are the so-called equitable partitions of matrices. In the following, we will look at computing equitable partitions of matrices with the tools of reloop, as well as  lifting factor graphs, solving linear equations and linear programs in a lifted fashion.</p>
<div class="section" id="equitable-partitions-of-matrices">
<h3><a class="toc-backref" href="#id8">Equitable Partitions of Matrices</a><a class="headerlink" href="#equitable-partitions-of-matrices" title="Permalink to this headline">¶</a></h3>
<p>Given is a tuple <span class="math">\(L=(\mathbf{A},\mathbf{b},\mathbf{c})\)</span>, where <span class="math">\(\mathbf{A}\in \mathbb{R}^{m\times n}, \mathbf{b}\in \mathbb{R}^{m}\)</span> and <span class="math">\(\mathbf{c}\in \mathbb{R}^{n}\)</span>. We say that a partition <span class="math">\({\cal P} = \{P_1,\ldots,P_p; Q_1,\ldots,Q_q\}\)</span> of <span class="math">\(L=(\mathbf{A},\mathbf{b},\mathbf{c})\)</span> is <strong>equitable</strong> if the following conditions hold.</p>
<ul class="simple">
<li>For any two columns <span class="math">\(i,\; j\)</span> in the same class <span class="math">\(P\)</span>, <span class="math">\(\mathbf{c}_i = \mathbf{c}_j\)</span>. For any two rows <span class="math">\(i,\; j\)</span> in the same class <span class="math">\(Q\)</span>, <span class="math">\(\mathbf{b}_i = \mathbf{b}_j\)</span>;</li>
<li>For any two columns <span class="math">\(i,\; j\)</span> in the same class <span class="math">\(P\)</span>, and for any constraint class <span class="math">\(Q\)</span> and real number <span class="math">\(r\)</span>:</li>
</ul>
<div class="math">
\[|\{k \in Q\ :\ \mathbf{A}_{ik} = r \}| = |\{l \in Q\ :\ \mathbf{A}_{jl} = r \}|\;.\]</div>
<ul class="simple">
<li>Analogously,  for any two rows <span class="math">\(i,\; j\)</span> in the same class <span class="math">\(Q\)</span>, and for any constraint class <span class="math">\(P\)</span> and real number <span class="math">\(r\)</span>:</li>
</ul>
<div class="math">
\[|\{k \in P :\ \mathbf{A}_{ki} = r \}| = |\{l \in P :\ \mathbf{A}_{lj} = r \}|\;.\]</div>
<p>Reloop provides an interface to the highly efficient code of <a class="reference external" href="http://vlsicad.eecs.umich.edu/BK/SAUCY/">Saucy</a> for the computation of equitable partitions of matrices. Currently, we can compute the coarsest equitable partition of a matrix, as well as its orbit partition. We will now show how to compute equitable partitions. We will now illustrate the basic concepts by lifting a factor graph so we can later run lifted belief propagation.</p>
</div>
<div class="section" id="lifting-an-mrf-factor-graph">
<h3><a class="toc-backref" href="#id9">Lifting an MRF Factor Graph</a><a class="headerlink" href="#lifting-an-mrf-factor-graph" title="Permalink to this headline">¶</a></h3>
<p>Suppose we are given the following factor graph (to the right).</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/factorgraph1.svg"><img alt="factor graph" src="_images/factorgraph1.svg" width="45%" /></a>
</div>
<p>We have two factors with identical tables, two observed variables (<span class="math">\(A\)</span> and <span class="math">\(B\)</span>) and one unobserved variable. Our aim is to compute a lifted factor graph (on the right) so we can run lifted belief propagation. We will now show how this is done in reloop.</p>
<p>We begin by importing the Saucy wrapper from reloop</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">reloop.utils.saucy</span> <span class="kn">as</span> <span class="nn">saucy</span>
</pre></div>
</div>
<p>We will also need <tt class="docutils literal"><span class="pre">scipy.sparse</span></tt> and <tt class="docutils literal"><span class="pre">numpy</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</pre></div>
</div>
<p>Now we must figure out how to represent our factor graph in a way that Saucy can understand. Let us make a few observations.</p>
<p>First, it is a bipartite graph. This suggest that we can encode it in a rectangular matrix, where the rows represent factors and the columns represent variables. I.e., we have <span class="math">\(\mathbf{A}_{fX} \neq 0\)</span> if variable <span class="math">\(X\)</span> is connected to factor <span class="math">\(f\)</span> and <span class="math">\(\mathbf{A}_{fX} = 0\)</span> otherwise. Now we need to figure out what the actual entry for an edge would be. The subtlety lies in the fact that our factor tables are not symmetric: <span class="math">\(f_1(A = \mathrm{True}, B = \mathrm{False}) \neq f_1(A = \mathrm{False}, B = \mathrm{True})\)</span>. In other words, the first and second positions of the factor are not exchangeable. To reflect this in the representation, we will set <span class="math">\(\mathbf{A}_{fX} = 1\)</span> if <span class="math">\(X\)</span> is connected to the first position of <span class="math">\(f\)</span> and <span class="math">\(2\)</span> if it is in the second position. Since these numbers are internally intepreted as colors, the actual choice of numbers is not important, as long as compatible positions (arguments of the factor that can be permuted) receive the same numbers, and incompatible positions receive different numbers.</p>
<p>Second, two of the variables are observced, one is not. We do not want to group observed and unobserved variables, so we need to distinguish them. We can do so by using the <span class="math">\(\mathbf{c}\)</span>-vector (depending on the possible states that the variables can take, we may need to use even more colors &#8212; this depends on the MRF; for now we assume they are binary), assigning a different value for <span class="math">\(B\)</span>. Also, in this case our two factor tables are identical, but were they different, we would need to prevent the factors for being grouped together. We could accomplish this in the same manner, by using the <span class="math">\(\mathbf{b}\)</span>-vector.</p>
<p>We thus end up with the following representation of the factor graph:</p>
<div class="math">
\[\begin{split} \mathbf{A}^F = \begin{bmatrix}
      1 &amp; 2 &amp; 0           \\[0.3em]
      0 &amp; 2 &amp; 1            \\[0.3em]
      \end{bmatrix}\;,
   \mathbf{b}^F = \begin{bmatrix}
  0\\
  0\\
\end{bmatrix} \text{ and } \mathbf{c}^F =       \begin{bmatrix}
  1\\
  0\\
  1\\
\end{bmatrix}\; .\end{split}\]</div>
<p>We can now input this in saucy. All our data needs to be in coo_matrix format, and <tt class="docutils literal"><span class="pre">b</span></tt> and <tt class="docutils literal"><span class="pre">c</span></tt> must be column vectors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>We can now call the equitable partition function and print the result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">rowpart</span><span class="p">,</span> <span class="n">colpart</span><span class="p">]</span> <span class="o">=</span> <span class="n">saucy</span><span class="o">.</span><span class="n">epBipartite</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;===&quot;</span>
<span class="k">print</span> <span class="s">&quot;row classes: &quot;</span><span class="p">,</span> <span class="n">rowpart</span>
<span class="k">print</span> <span class="s">&quot;column classes: &quot;</span><span class="p">,</span> <span class="n">colpart</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">1</span></tt> in the last argument of <tt class="docutils literal"><span class="pre">epBipartite()</span></tt> indicates we are computing the coarsest equitable partition. To compute orbits, we use <tt class="docutils literal"><span class="pre">0</span></tt>.
When ran, this python code (also found at <a class="reference internal" href="python_lift_factorgraph.html#epfg"><em>lift_factorgraph.py</em></a>) outputs the following:</p>
<div class="highlight-python"><div class="highlight"><pre>entring wrapper with 2 rows, 3 cols and 4 entries.
row colors: 1
col colors: 3
nodes 9
edges 8
input file = (null)
vertices = 9
edges = 8
group size = 1.000000e0
levels = 0
nodes = 1
generators = 0
total support = 0
average support = -nan
nodes per generator = inf
bad nodes = 0
cpu time (s) = 0.00
===
row classes:  [0 0]
column classes:  [1 0 1]
</pre></div>
</div>
<p>After the debug output of Saucy we can read off the partition. For the variable (column classes)  <span class="math">\(A\)</span> and <span class="math">\(C\)</span> are placed in class <span class="math">\(1\)</span>, while <span class="math">\(B\)</span> is placed in class <span class="math">\(0\)</span>. Also, both factors (row classes) are in the same class. This is exactly what we expected from the example.</p>
<p>The actual lifted factor graph construction having the colors follows as in (TODO: Babak&#8217;s paper).</p>
<p>Note that the actual numbering of the classes is not guaranteed to follow any particular convention.</p>
</div>
<div class="section" id="lifting-linear-programs">
<h3><a class="toc-backref" href="#id10">Lifting Linear Programs</a><a class="headerlink" href="#lifting-linear-programs" title="Permalink to this headline">¶</a></h3>
<p>Let us consider the following LP:</p>
<div class="math">
\[\begin{split}\operatorname*{minimize}_{[x,y,z]^T \in \mathbb{R}^3}\quad  &amp;\; 0x + 0y + 1z\\
\text{subject to}\quad &amp; \begin{bmatrix}
   1 &amp; 1 &amp; 1           \\[0.3em]
   -1 &amp; 0 &amp; 0            \\[0.3em]
   0 &amp; -1 &amp; 0            \\[0.3em]
   1 &amp; 1 &amp; -1            \\[0.3em]
 \end{bmatrix}
  \begin{bmatrix}
   x\\
   y\\
   z\\
 \end{bmatrix} \leq
       \begin{bmatrix}
   1\\
   0\\
   0\\
   -1\\
 \end{bmatrix}\;.\end{split}\]</div>
<p>It can be verified that an equitable partition of the above LP is <span class="math">\({\cal P}^0 = \{\{1,2\},\{3\};\{1\}\{2,3\}\{4\} \}\)</span> &#8212; meaning that column <span class="math">\(c_1\)</span> is equivalent to <span class="math">\(c_2\)</span> but not to <span class="math">\(c_3\)</span> and rows <span class="math">\(r_2\)</span> and <span class="math">\(r_3\)</span> are equivalent, but not rows <span class="math">\(r_1\)</span> and <span class="math">\(r_4\)</span>. Using this equitable partition, we can derive a new LP, smaller in size, whose set of solutions is a subset of the solutions of the original one. The method of this reduction is described in detail in (TODO: RLP). In short, we reduce the number of rows by leaving only one row per row-class. Then, we reduce the number of columns by removing all columns in the same class from the LP, then inserting back a single representative column which is their sum.  The lifted LP is thus</p>
<div class="math">
\[\begin{split}\operatorname*{minimize}_{[{\mathfrak x},z]^T \in \mathbb{R}^2}\quad  &amp;\; 0 {\mathfrak x} + 1z\\
\text{subject to}\quad &amp; \begin{bmatrix}
   2 &amp;  1           \\[0.3em]
   -1  &amp; 0             \\[0.3em]
   2 &amp; -1            \\[0.3em]
 \end{bmatrix}
  \begin{bmatrix}
  {\mathfrak x}\\
   z\\
 \end{bmatrix} \leq
       \begin{bmatrix}
   1\\
   0\\
   -1\\
 \end{bmatrix}\;.\end{split}\]</div>
<p>Within reloop, lifting LPs is achieved through the <tt class="docutils literal"><span class="pre">utils.liftAbc()</span></tt> function. The following code snippet shows how.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

<span class="k">print</span> <span class="s">&quot;input LP:&quot;</span>
<span class="k">print</span> <span class="s">&quot;c: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;b: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
<span class="k">print</span> <span class="s">&quot;A: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>

<span class="n">LA</span><span class="p">,</span> <span class="n">Lb</span><span class="p">,</span> <span class="n">Lc</span><span class="p">,</span> <span class="n">compresstime</span><span class="p">,</span> <span class="n">Bcc</span> <span class="o">=</span> <span class="n">saucy</span><span class="o">.</span><span class="n">liftAbc</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">orbits</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&quot;lifted LP:&quot;</span>
<span class="k">print</span> <span class="s">&quot;lifted c: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Lc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Lb: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Lb</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;LA: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
</pre></div>
</div>
<p>(TODO: fix sparsity of b and c)
The minimal working example is found at <a class="reference internal" href="python_lift_Abc.html#liftabc"><em>lift_Abc.py</em></a>. Executing this code yields</p>
<div class="highlight-python"><div class="highlight"><pre>input LP:
c: [[0 0 1]]
b: [[ 1]
 [ 0]
 [ 0]
 [-1]]
A: [[ 1  1  1]
 [-1  0  0]
 [ 0 -1  0]
 [ 1  1 -1]]
entring wrapper with 4 rows, 3 cols and 8 entries.
row colors: 3
col colors: 5
nodes 15
edges 16
input file = (null)
vertices = 15
edges = 16
group size = 1.000000e0
levels = 0
nodes = 1
generators = 0
total support = 0
average support = -nan
nodes per generator = inf
bad nodes = 0
cpu time (s) = 0.00
refinement took:  0.01 seconds.
lifted LP:
lifted c: [[0 1]]
Lb: [[-1]
 [ 0]
 [ 1]]
LA: [[ 2 -1]
 [-1  0]
 [ 2  1]]
</pre></div>
</div>
<p>We can read off the lifted LP at the bottom of the output. Note that while the LP agrees with what we expected, the order of the inequalities is different (first and third are switched). This is an artifact of the implementation. It does not, however, change the feasible region of the LP.</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/tutorial.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2014, Martin Mladenov, Kristian Kersting, Danny Heinrich.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>