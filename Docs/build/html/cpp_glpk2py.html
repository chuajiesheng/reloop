
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Glpk2Py &mdash; reloop 0.0.1a documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-3.2.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="_static/ls8layout.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="reloop 0.0.1a documentation" href="index.html" />
    <link rel="up" title="CPlusPlus" href="cpp.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="Fc" href="cpp_fc.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www-ai.cs.uni-dortmund.de/weblab/index.html"><img class="intro-logo" src="_static/tulogo.svg">
        </a>
        <span class="navbar-text navbar-ls8-title">
          reloop<span class="navbar-version"><b> (0.0.1)</b></span>
        </span>
      </div>

      <div class="collapse navbar-collapse nav-collapse navbar-right">
        <ul class="nav navbar-nav">
          
              <li><a href="index.html">Home</a></li>
              <li><a href="download.html">Download</a></li>
          
          
            
<li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Index <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installation.html#main-dependencies">Main dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#optional-dependencies">Optional dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="installation.html#installing-reloop">Installing reloop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#relational-linear-programming">Relational Linear Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#lifted-linear-programming">Lifted Linear Programming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="RAMPL.html">RAMPL</a></li>
<li class="toctree-l1"><a class="reference internal" href="LLP.html">LLP</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python_maxflow_operator.html">maxflow_operator.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="python_maxflow_text.html">maxflow_text.py</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="code.html">Code</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="python.html">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="cython.html">Cython</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="cpp.html">CPlusPlus</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>
</ul>
</li>
            
          
          
          
          
          
        </ul>

        
          
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        
      </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="glpk2py">
<h1>Glpk2Py<a class="headerlink" href="#glpk2py" title="Permalink to this headline">¶</a></h1>
<div class="section" id="members">
<h2>Members<a class="headerlink" href="#members" title="Permalink to this headline">¶</a></h2>
<div class="section" id="filetype">
<h3>Filetype<a class="headerlink" href="#filetype" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="glpk2py::filetype__enum">
enum <tt class="descclassname">glpk2py::</tt><tt class="descname">filetype</tt><a class="headerlink" href="#glpk2py::filetype__enum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>The Format of a given file</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="12%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MPS</td>
<td>0</td>
<td>Given file is in the MPS format</td>
</tr>
<tr class="row-odd"><td>LP</td>
<td>1</td>
<td>Given file is in the LP format</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="bounds">
<h3>Bounds<a class="headerlink" href="#bounds" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="glpkl2py::bounds__enum">
enum <tt class="descclassname">glpkl2py::</tt><tt class="descname">bounds</tt><a class="headerlink" href="#glpkl2py::bounds__enum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Flags, which indicate the different bounds to be calculated for given LP.
For instance if UPPER is set the function getMatrix() will calculate the upper bounds for the specified LP object.</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="16%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UPPER</td>
<td>0</td>
<td>Upper Bounds ax &gt; b</td>
</tr>
<tr class="row-odd"><td>LOWER</td>
<td>1</td>
<td>Lower Bounds ax &lt; b</td>
</tr>
<tr class="row-even"><td>EQUAL</td>
<td>2</td>
<td>Fixed Bounds ax = b</td>
</tr>
<tr class="row-odd"><td>UNBOUND</td>
<td>3</td>
<td>Unbound ax &lt; 0</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="scaling">
<h3>Scaling<a class="headerlink" href="#scaling" title="Permalink to this headline">¶</a></h3>
<dl class="member">
<dt id="glpk2py::scaling__enum">
enum <tt class="descclassname">glpk2py::</tt><tt class="descname">scaling</tt><a class="headerlink" href="#glpk2py::scaling__enum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Flags used for distinguishing between the different scaling types to be used by the defined functions.</div></blockquote>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>GEOMEAN</td>
<td>0</td>
<td>Geometric mean scaling</td>
</tr>
<tr class="row-odd"><td>EQUILIB</td>
<td>1</td>
<td>Equilibration scaling</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="openlp">
<h3>openLP<a class="headerlink" href="#openlp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::openLP__ssCR.i">
void <tt class="descclassname">glpk2py::</tt><tt class="descname">openLP</tt><big>(</big>const std::string&amp; <em>fname</em>, int <em>format</em><big>)</big><a class="headerlink" href="#glpk2py::openLP__ssCR.i" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Opens the LP by creating a glpk problem object and assigning the given file to it n
Furthermore extracts the number of columns and rows of the opened LP and assigns the values to global variables</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fname</strong> &#8211; The name of the file to be opened</li>
<li><strong>format</strong> &#8211; The filetype of given file either MPS or LP are valid (see enum filetype)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Type fname:</th><td class="field-body"><p class="first">string.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type format:</th><td class="field-body"><p class="first last">int.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="closelp">
<h3>closeLP<a class="headerlink" href="#closelp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::closeLP__X">
void <tt class="descclassname">glpk2py::</tt><tt class="descname">closeLP</tt><big>(</big><em>void</em><big>)</big><a class="headerlink" href="#glpk2py::closeLP__X" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes LP by calling the destructor of glpk, which deallocates all memory used by the corresponding problem object iff the constructor was called in openLPn
The call of glp_free_env() frees all resources used by GLPK routines</p>
</dd></dl>

</div>
<div class="section" id="getmatrix">
<h3>getMatrix<a class="headerlink" href="#getmatrix" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::getMatrix__bounds.i">
vector&lt;double&gt; <tt class="descclassname">glpk2py::</tt><tt class="descname">getMatrix</tt><big>(</big>bounds <em>boundquery</em>, int <em>scaled</em><big>)</big><a class="headerlink" href="#glpk2py::getMatrix__bounds.i" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Computes a Matrix depending on the boundquery argument (see bounds)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>boundquery</strong> &#8211; Flag to determine, which inquality is going to be calculated</li>
<li><strong>scaled</strong> &#8211; An integer, which indicates a scaled matrix(LP)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Type boundquery:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">bounds.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type scaled:</th><td class="field-body"><p class="first">int.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A vector of the type double and 4 x n dimensions, which contains the data.</p>
</td>
</tr>
</tbody>
</table>
<p>Computes a Matrix depending on the boundquery Argument (see bounds)
UPPER &#8211;Calculates the Upper bounds of a given LP and returns it as a vector
LOWER &#8211;Calculates the Lower bounds of a given LP and returns it as a vector
EQUAL &#8211; Calculates fixed variables of a given LP and returns it as a vector
UNBOUND &#8211; Calculates unbound variables of a given LP</p>
</dd></dl>

</div>
<div class="section" id="getobjective">
<h3>getObjective<a class="headerlink" href="#getobjective" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::getObjective__i">
vector&lt;double&gt; <tt class="descclassname">glpk2py::</tt><tt class="descname">getObjective</tt><big>(</big>int <em>scaled</em><big>)</big><a class="headerlink" href="#glpk2py::getObjective__i" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Calculates the objective of a given LP</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Parameters scaled:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">An integer, which indicates a scaled matrix(LP)</td>
</tr>
<tr class="field-even field"><th class="field-name">Type scaled:</th><td class="field-body">int.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The Objective of an opened LP as vector of type double.</td>
</tr>
</tbody>
</table>
<p>Creates a new vector object with the size of the number of columns of given lp then iterates over this vector and
calculates the objective coefficient at the i-th column of the lp (problem) object. If the problem is scaled
the scale factor s is set to the current scaled factor and the current position of the matrix of the lp object.</p>
</dd></dl>

</div>
<div class="section" id="doscaling">
<h3>doScaling<a class="headerlink" href="#doscaling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::doScaling__scaling">
void <tt class="descclassname">glpk2py::</tt><tt class="descname">doScaling</tt><big>(</big>scaling <em>sctype</em><big>)</big><a class="headerlink" href="#glpk2py::doScaling__scaling" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Wrapper function for the glp scaling method, which does the actual scaling of the given lp.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Parameters sctype:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">Flag, which determines the type of scaling to be executed for a given LP</td>
</tr>
<tr class="field-even field"><th class="field-name">Type sctype:</th><td class="field-body">scaling.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="solve">
<h3>Solve<a class="headerlink" href="#solve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="glpk2py::solve">
void <tt class="descclassname">glpk2py::</tt><tt class="descname">solve</tt><big>(</big><big>)</big><a class="headerlink" href="#glpk2py::solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the given LP with an off-the-shelf LP-Solver for instance using the Gnu GLPK</p>
</dd></dl>

</div>
</div>
<div class="section" id="source">
<h2>Source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;glpk2py.h&quot;</span>
<span class="cp">#include &lt;limits&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;math.h&gt;</span>
<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#define DEBUG 0</span>

<span class="cp">#include &lt;stdio.h&gt;            </span><span class="cm">/* C input/output                       */</span><span class="cp"></span>
<span class="cp">#include &lt;stdlib.h&gt;           </span><span class="cm">/* C standard library                   */</span><span class="cp"></span>
<span class="cp">#include &lt;glpk.h&gt;             </span><span class="cm">/* GNU GLPK linear/mixed integer solver */</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">glp_prob</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">///&lt; Global pointer to a yet to be specified glp object</span>
<span class="kt">int</span> <span class="n">numrows</span><span class="p">;</span>  <span class="c1">///&lt; Number of rows of a given glp object</span>
<span class="kt">int</span> <span class="n">numcols</span><span class="p">;</span> <span class="c1">///&lt; Number of columns of a given glp object</span>


<span class="c1">/// Opens the LP by creating a glpk problem object and assigning the given file to it \n</span>
<span class="c1">/// Furthermore extracts the number of columns and rows of the opened LP and assigns the values to global variables</span>
<span class="kt">void</span> <span class="nf">openLP</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">fname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">format</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fname</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">lp</span> <span class="o">=</span> <span class="n">glp_create_prob</span><span class="p">();</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">MPS</span><span class="p">:</span>
      <span class="n">glp_read_mps</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">GLP_MPS_FILE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">fname</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">LP</span><span class="p">:</span>
      <span class="n">glp_read_lp</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">fname</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">numrows</span> <span class="o">=</span> <span class="n">glp_get_num_rows</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
  <span class="n">numcols</span> <span class="o">=</span> <span class="n">glp_get_num_cols</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;end&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Closes LP by calling the destructor of glpk, which deallocates all memory used by the corresponding problem object iff the constructor was called in openLP\n</span>
<span class="c1">/// The call of glp_free_env() frees all resources used by GLPK routines</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="nf">closeLP</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glp_delete_prob</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
    <span class="n">glp_free_env</span><span class="p">();</span>
    <span class="n">numrows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">numcols</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// Computes a Matrix depending on the boundquery Argument (see bounds) \n</span>
<span class="c1">/// UPPER --Calculates the Upper bounds of a given LP and returns it as a vector\n</span>
<span class="c1">/// LOWER --Calculates the Lower bounds of a given LP and returns it as a vector\n</span>
<span class="c1">/// EQUAL -- Calculates fixed variables of a given LP and returns it as a vector\n</span>
<span class="c1">/// UNBOUND -- Calculates unbound variables of a given LP</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">getMatrix</span><span class="p">(</span><span class="n">bounds</span> <span class="n">boundquery</span><span class="p">,</span><span class="kt">int</span> <span class="n">scaled</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itera</span><span class="p">,</span> <span class="n">iterb</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indvec</span> <span class="p">(</span><span class="n">numcols</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">datavec</span> <span class="p">(</span><span class="n">numcols</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>


  <span class="kt">int</span> <span class="n">nonzero</span> <span class="o">=</span> <span class="n">glp_get_num_nz</span><span class="p">(</span><span class="n">lp</span><span class="p">);</span>
  <span class="c1">//npy_intp dims[] = {4,0};</span>
  <span class="kt">int</span> <span class="n">dims</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nonzero</span> <span class="o">+</span> <span class="n">numcols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// we return variable bounds as constraints, hence the numcols.</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">sparsematrix</span><span class="p">;</span>
  <span class="n">sparsematrix</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">);</span>

  <span class="n">itera</span> <span class="o">=</span> <span class="n">sparsematrix</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">iterb</span> <span class="o">=</span> <span class="n">itera</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="p">;</span>
  <span class="cm">/*incredibly, glpk array indices start from 1...*/</span>
  <span class="kt">int</span> <span class="n">foundrows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">boundtype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">//vector globalindvec;</span>
  <span class="c1">//vector globaldatavec;</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">EQUAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">UNBOUND</span><span class="p">))</span> <span class="n">boundtype</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">rowtype</span> <span class="o">=</span> <span class="n">glp_get_row_type</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">boundtype</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>   <span class="p">(</span><span class="n">rowtype</span> <span class="o">==</span> <span class="n">boundquery</span><span class="p">)</span> <span class="p">)</span> \
      <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">boundtype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">rowtype</span> <span class="o">==</span> <span class="n">GLP_DB</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rowtype</span> <span class="o">==</span> <span class="n">boundquery</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>


      <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">datavec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">datavec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span> <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">indvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">indvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">len</span> <span class="o">=</span> <span class="n">glp_get_mat_row</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">indvec</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">datavec</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;WARNING!! Zero elements in row %s of type </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">glp_get_row_name</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">));</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">scaled</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;=</span><span class="n">len</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">double</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">datavec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">p</span><span class="p">);</span>
          <span class="n">tmp</span> <span class="o">=</span> <span class="n">glp_get_rii</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">tmp</span><span class="o">*</span><span class="n">glp_get_sjj</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="o">*</span><span class="p">(</span><span class="n">indvec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">p</span><span class="p">));</span>
          <span class="o">*</span><span class="p">(</span><span class="n">datavec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">indvec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">indvec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">itera</span><span class="p">);</span>
     <span class="cm">/* for (std::vector&lt;int&gt;::iterator it = indvec.begin()+1; it &lt;= indvec.begin() + len; it++) cout &lt;&lt; *it;</span>
<span class="cm">      cout &lt;&lt; endl;*/</span>
      <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">itera</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="n">itera</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">foundrows</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">datavec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">datavec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">itera</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">);</span>

      <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">scaled</span><span class="p">)</span> <span class="n">r</span> <span class="o">=</span> <span class="n">glp_get_rii</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
      <span class="k">if</span>  <span class="p">((</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">EQUAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">UPPER</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
       <span class="o">*</span><span class="n">iterb</span> <span class="o">=</span> <span class="n">glp_get_row_ub</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rowtype</span> <span class="o">==</span> <span class="n">LOWER</span><span class="p">)</span> <span class="o">*</span><span class="n">iterb</span> <span class="o">=</span> <span class="n">glp_get_row_lb</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

      <span class="n">itera</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
      <span class="n">iterb</span><span class="o">++</span><span class="p">;</span>
      <span class="n">foundrows</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span>
  <span class="c1">//variable bounds as constraints.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numcols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">coltype</span> <span class="o">=</span> <span class="n">glp_get_col_type</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">//if variable is unbounded, we don&#39;t want to return anything</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">EQUAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>  <span class="p">(</span><span class="n">coltype</span> <span class="o">==</span> <span class="n">boundquery</span><span class="p">)</span> <span class="p">)</span> \
      <span class="o">||</span> <span class="p">(</span> <span class="p">(</span><span class="n">boundtype</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span> <span class="p">(</span><span class="n">coltype</span> <span class="o">==</span> <span class="n">GLP_DB</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">coltype</span> <span class="o">==</span> <span class="n">boundquery</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">itera</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="n">itera</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">foundrows</span><span class="p">;</span>
      <span class="o">*</span><span class="p">(</span><span class="n">itera</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="c1">//if (scaled) r = glp_get_rii(lp,i);</span>
      <span class="c1">//**************TODO: FIGURE OUT HOW TO FIX THE SCALING OF COLUMN BOUNDS***********</span>
      <span class="k">if</span>  <span class="p">((</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">EQUAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">UPPER</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">iterb</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">glp_get_col_ub</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">boundquery</span> <span class="o">==</span> <span class="n">LOWER</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">iterb</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">glp_get_col_lb</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">itera</span><span class="o">++</span><span class="p">;</span>
      <span class="n">iterb</span><span class="o">++</span><span class="p">;</span>
      <span class="n">foundrows</span><span class="o">++</span><span class="p">;</span>


    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">sparsematrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numcols</span><span class="p">;</span>
  <span class="n">sparsematrix</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">foundrows</span><span class="p">;</span>
  <span class="n">sparsematrix</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">itera</span> <span class="o">-</span> <span class="n">sparsematrix</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">sparsematrix</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">iterb</span> <span class="o">-</span> <span class="n">sparsematrix</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">//itera = sparsematrix.begin();</span>
  <span class="c1">//for (  pyublas::numpy_array&lt;double&gt;::iterator tmp = iter; tmp &lt; iter + 50; tmp++) cout &lt;&lt; *tmp;</span>
  <span class="k">return</span> <span class="n">sparsematrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Creates a new vector object with the size of the number of columns of given lp then iterates over this vector and</span>
<span class="c1">/// calculates the objective coefficient at the i-th column of the lp (problem) object. If the problem is scaled</span>
<span class="c1">///the scale factor s is set to the current scaled factor and the current position of the matrix of the lp object.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">getObjective</span><span class="p">(</span><span class="kt">int</span> <span class="n">scaled</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">objective</span><span class="p">(</span><span class="n">numcols</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itera</span><span class="p">;</span>
  <span class="n">itera</span> <span class="o">=</span> <span class="n">objective</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numcols</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scaled</span><span class="p">)</span> <span class="n">s</span> <span class="o">=</span> <span class="n">glp_get_sjj</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="o">*</span><span class="n">itera</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="n">glp_get_obj_coef</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">itera</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*for (pyublas::numpy_vector&lt;double&gt;::iterator iterb = objective.begin(); iterb &lt; objective.end(); iterb++) {</span>
<span class="cm">    cout &lt;&lt; *iterb &lt;&lt; &quot;, &quot;;</span>
<span class="cm">  }</span>
<span class="cm">  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">glp_get_obj_dir</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="o">==</span> <span class="n">GLP_MIN</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">transform</span><span class="p">(</span><span class="n">objective</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">objective</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">objective</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">bind1st</span><span class="p">(</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">objective</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">objective</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// Wrapper function for the glp scaling method, which does the actual scaling of the given lp.</span>
<span class="kt">void</span> <span class="n">doScaling</span><span class="p">(</span><span class="n">scaling</span> <span class="n">sctype</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">glp_scale_prob</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">sctype</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Solves the given (lifted) lp</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">glp_simplex</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/cpp_glpk2py.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright .<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>